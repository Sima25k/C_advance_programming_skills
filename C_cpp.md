# C语言入门	
`-网易云课堂`
## Content
- c/c++起源、市场需求、开发环境
- 数据类型	、运算符、表达式的介绍
	- 常量和变量、整型、实型、字符型
	- 算数型运算符和表达式
	- 赋值型运算符和逗号运算符
- 程序的基本结构和语句
	- C语言的语句和程序的基本结构
	- 数据的输出与数据的输入
- 逻辑运算和判断选择
	- 关系运算符、关系表达式、逻辑运算符、逻辑表达式
	- if语句详解
	- 条件运算符和switch语句
- 循环控制
	- 概述、goto、while、do while语句精解
	- for语句精解
	- 循环的嵌套、比较、break语句、continue语句
- 数组
	- 一维数组
	- 二维数组
	- 字符数组
- 函数
	- 函数的基本概念和定义
	- 函数调用方式及嵌套调用
	- 函数递归调用精彩演绎
	- 数组作为函数参数
	- 局部变量和全局变量
	- 变量的存储和引用、内部和外部函数
- 编译预处理
	- 宏定义
	- 文件包含和条件编译
- 指针
	- 指针基本概念详解
	- 变量的指针和指向变量的指针变量
	- 数组的指针和指向数组的指针变量
	- 字符串的指针和指向字符串的指针变量
	- 函数指针和返回指针值的函数
	- 指针数组、指针的指针、main函数参数、小结
- 结构体与共用体
	- 结构体变量定义、引用、初始化
	- 结构体数组、结构体指针
	- 共用体、枚举类型、typedef
- 位运算
	- 位的概念以及位运算符介绍
	- 位运算的具体应用
- 文件
	- 文件概述、文本、二进制文件区别
	- 文件的开、关、读、写、实战操练
	- 将结构体写入二进制文件再读出
- 课程总结与未来展望

***
## 一 数据类型、运算符、表达式的介绍
### 1、常量和变量、整型、实型、字符型
- 新建项目 
- 一个解决方案下可包含多个项目

运行快捷键 `ctrl+fn+F5` 
添加debug断点快捷键 `fn+F9` 
在debug模式下运行下一步`fn+F10`

换行语句`\n` 单行注释`//` 多行注释`/* */`

**C语言每行语句的末尾都要有`;`**

### 2、数据类型
> 字节越大表达范围越大（标注的前为32位后为64位）

- 基本类型
	- 数值类型
		- 整型
			- 短整型`short` *2/2*
			- 整型`int` *4/4*
			- 长整型`long` *4/8*
		- 浮点型
			- 单精度型`float` *4/4*
			- 双精度型`double` *8/8*
	- 字符类型`char`	*1/1*
- 构造类型
	- 数组
	- 结构体`struct`
	- 共用体`union`
	- 枚举类型`enum`
- 指针类型
- 空类型`void`

### 3、常量
> 在程序运行中其值不变的量

```
150;	//整型变量
12.3;	//实型变量（浮点型变量）
'a';	//字符常量
```

### 4、变量
> 组成：
>> 标志符：由字母，数字，下划线组成，并且第一个字符为字母或下划线。
>> 保留字：系统保留起来有特殊用途，不能作标识符使用。

*变量名是标识符，变量名区分大小写*

### 5、整型数据
#### 1）整型常量
```
123;
-456;	//(十进制)
012;	//(八进制，以0开头的数字)
0x123;	//(十六进制，以0x开头)
```
#### 2）整型变量
- 基本型 `int` （4字节）
- 短整型 `short int`	`short`（2字节）
- 长整型 `long int`	`long`	
- 无符号型`unsigned int`	`unsigned short`	`unsigned long`	只能保存不带符号的数字，**不能存负数**	*范围大一倍*

`sizeof` 确定一个类型变量在内存中占多少字节。


```
printf("abc这个变量占的字节数是%d\n",sizeof(abc));
```

### 6、实型数据（浮点型数据）
#### 1）实型常量
```
2.9;	//十进制浮点数
168E2;
168E-2;	//指数形式浮点数；在内存中实型数据以指数形式存储，E前/后 分开存储
```
#### 2）实型变量
- 单精度变量`float`	一般提供7位有效数字
- 双精度变量`double`	一般提供15-16位有效数字

printf中`%f`用来输出10进制的浮点数，`%.20f`表示保留二十位小数的浮点数。

### 7、字符型数据（一个字节）
#### 1）常规字符：*用单引号引起来的一个字符*
#### 2）特殊字符`转义字符`：*以\开头的字符序列*
- `\f` 换页
- `\n` 换行
- `\\` 反斜杠
- `\'` 单引号字符
- `\"` 双引号字符

#### 3）字符变量：*只能保存一个字符* `char`
> 因为一个字符型变量在内存中只占一个字节

```
char c1,c2,c3;
c1 = 'a';	//事实上是把字符对应的ascii码保存在了内存中
c2 = 'b';
c3 = '\"';
```

[ASCII码	对照表](http://www.asciima.com/ascii/12.html)

**字符数据即能以字符形式输出，也能以ascii表对应的整数形式输出**

`printf`中`%c`用来输出字符型数据
### 8、字符型常量	*（两个字节）*
> 用`""`引起来的一堆字符

```
c1 = 'a';
c2 = "a";
```
**在内存中**
`a`	字符c1（1个字节）
`a``\0`	字符串c2（2个字节）

`\0` 字符串结束标记，在`printf`时并不输出。

### 9、变量赋初值
```
int a, b, c = 6;	//只给c赋值，c语言中变量要先定义后使用
```

### 10、数值型数据的混合运算
> 系统中不同数据类型运算时，系统会尝试将类型统一。
系统会选取变量中能表达最大数字的变量，作为转化的最大类型。

```
double <-- float
double <-- long <-- unsigned <-- int <-- char,short
```

### 11、C语言的运算符
#### 1）算术运算符和算术表达式

`+`，`-`，`*`，`/`，`%`*（取余，也叫模运算符，该运算符两侧都要求为整数）*
> 两整数相除，系统会舍弃小数部分。

**优先级问题**：先乘除后加减，优先级相同时，按顺序计算。

#### 2）**赋值运算符**: `=`

#### 3）**强制类型转换运算符**：将一个表达式转换成所需要的类型。强制类型转换得到的是一个所转换到的类型的中间变量。

- 一般形式：`(类型)(表达式)`

```
int a = 10;
double b;
b = (double)a;	
//a本身类型并没有变化而是整个结果的类型发生变化赋值给了b
```
**两种类型转换**
1. *自动类型转换*
2. *强制类型转换*
#### 4）自增和自减操作符	`++`*自增*	`--`*自减*
`i++`相当于i自身加了1，然后结果再赋给i。
> 用于循环语句中给自己加一减一

```
int i;
i++;	//先用后加
++i;	//先加后用
```

##### 运算优先级
![运算优先级](https://i.loli.net/2019/12/25/ZtqEQ25beLAHmJn.jpg)
![运算优先级](https://i.loli.net/2019/12/25/8HRfQ16sLmjaiEO.jpg)
#### 5）赋值运算符和赋值表达式
**赋值运算符**   `=` ： 将等号右边的值赋给等号左边的变量，等号左边是个变量（给变量一个值或者改变变量到某一个值）。

```
//几个概念
char a;	//这个叫变量定义，系统会给a分配一个字节的内存，内存里面的值不确定
char a = 90;//这个叫变量定义，同时给变量赋初值（定义时初始化）
                     i//字符的范围是-128到+127
a = 900；  //赋值语句。会造成溢出，溢出后a里面的内容就会变得不可预料
```

**赋值的原则**：类型要相同，类型不同的用强制类型转换，必须明确知道不会溢出。

##### 复合的赋值运算符（具有从右到左结合性）：
在赋值运算符 `=` 之前加上其他运算符，构成了复合的赋值运算符*（复合的赋值运算符的两个运算符之间必须紧挨着不能用空格分开）*
- `+=`：  `a += 3` 相当于 `a = a + 3`。
- `*=`:     `x *= y + 8` 相当于 `x = x * (y + 8)` //如果`*=`右侧是个表达式的话，则相当于该表达式有括号。
- `%=`：近似上述。

> 赋值表达式（复合的赋值表达式）本身也是有值的 —— 表达式的值等于等号右边的值

#### 6）逗号运算符和逗号表达式
**逗号运算符**：将两个表达式连接起来；**它的优先级是最低的！**

**格式**：`表达式1，表达式2`

**求解过程**：先求解表达式1的值再求解表达式2，整个表达式的值是表达式2的值

```
int a;
a = 3*5, a*4    //结果是a=15, 整个表达式的值为60
```

**逗号表达式的扩展形式**
`表达式1, 表达式2, ... 表达式N`

## 二 程序的基本结构和C语言的语句
不同的字符所占的字节是不同的。

```
ASCII码：
一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为8位二进制数，换算为十进制。最小值0，最大值255。如一个ASCII码就是一个字节。8bit(位)=1byte(字节)。
UTF-8编码：
一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。
Unicode编码：
一个英文等于两个字节，一个中文（含繁体）等于两个字节。
符号：
英文标点占一个字节，中文标点占两个字节。举例：英文句号“.”占1个字节的大小，中文句号“。”占2个字节的大小。
```

### 1、语句的分类
  
- **控制语句**：*能够控制程序的执行流程，比如在一定的条件下执行某些语句，在另外的条件下，不执行该语句。*

- **函数调用语句**：*由一个函数调用末尾增加个分号构成的语句。*

- **表达式语句**：*由一个表达式构成的语句。*

- **空语句**：*就一个分号。*

- **复合语句**：*用{}括起来的语句。*

#### **⚠️	注意点**
- C语言允许在一行上写几个语句。

- C语言允许一个语句拆开几行写。(上一行用`\`结尾，进入下一行，这两行组成一个完整行）

```
printf(“断点停在\
这里”)
```
#### 1）程序的三种基本结构：
- 顺序结构：先执行A操作再执行B操作;

- 选择结构：条件为真执行A操作，条件为假执行B操作;

```
if(3 >1)
{
	printf(“3 > 1\n”);
}
else
{	
	printf(“3 < 1\n”);
}
//补充：多分枝选择结构switch
int k = 5;
switch(k)
{
case 1:
	{
		printf(“icount =1\n”);
	}
	break;
case 5:
	{
		printf(“icount = 5\n”);
	}
	break;
}
```
- 循环结构：
	- 当型循环结构：先判断条件，才决定是否执行A操作，当P条件成立时，就一直反复的执行A操作，知道条件为假才停止循环。

```
int icount = 5;
while(icount >= 0)
{
	printf(“icount = %d\n:,icount);
	icount -= 1;
}
```
- 循环结构	
	- 直到型循环结构：先执行A操作，再判断条件，条件满足时反复执行操作，知道判断条件P为假停止循环。（至少执行一次A操作）

```
int icount = 5;
do
{	
	printf(“icount = %d\n”,icount);
	icount -= 1;
}while(icount >= 0);
```

### 2、赋值语句的特殊写法

```
printf(“x=8的值是%d”, x=8);
int a = 3, b = 4;
int x;	
if ( (a = b) > 0)
	x = 4;
```

### 3、数据的输出
`putchar(c)`: *向屏幕输出一个字符，只能输出字符。c可以是个字符型变量，也可以是个整形变量。*

`#include< >`：**预编译命令，作用就是将某些文件包含到用户的源文件中，也就相当于把某个文件中的内容原封不动的贴到这个位置。**

```
#include <stdio.h>       //<>是去系统目录中找头文件
#include “stdio.h”        //“”在当前目录中查找，找不到再到系统中查找。“”用于自己写的头文件，让系统优先使用当前目录中定义的头文件。
```
`stdio.h`     //标准的I/O库；`stdio.h`叫头文件(head)

`printf()`函数：**向屏幕输出若干任意类型的数据。**
**格式：**`printf(格式控制,输出表列);`
**格式控制：**用双引号扩起来的字符串。

**格式字符：**

- `%d`:以十进制数形式输出一个数字；
- `%o`:以八进制数形式输出一个数字；
- `%x`:以十六进制数形式输出一个数字;
- `%c`:以字符形式输出一个数字;
- `%f`:以浮点数形式输出一个数字；
- `%u`:以十进制数形式输出一个unsigned型（正数）数据；
- `%s`:输出一个字符串；（string）

`printf`中显示`%`
1. `printf("5%%");`
2. `printf("5%c",'%');`
3. `printf("5%s","%");`

### 4、数据的输入：从键盘上输入数据。
`getchar()`：执行后等待用户从键盘上输入一个字符，并按回车后程序继续执行。

`scanf`函数，这是个格式化输入函数，用来输入任何类型的多个数据;
**格式：**
`scanf(格式控制，地址表列);`
当输入回车的时候表示输入结束。

```
int a, b, c;
scanf_s(“%d%d%d”,&a,&b,&c);	//&是地址运算符（表示该变量在内存中的地址），表示键盘输入的数据放在a, b, c的地址中。三个输入的数字 之间可以用空格，回车，tab分隔，不能用逗号分隔。
printf(“a+b+c=“,a+b+c);
```

## 三 逻辑运算和判断选择

### 1、关系运算符，关系表达式，逻辑运算符，逻辑表达式
#### 1）关系运算符和关系表达式
**关系表达式：**用关系运算符将两个表达式连接起来的式子就叫关系表达式。

关系表达式的值是一个*逻辑值*，**“True(1)”和“False(0)”（布尔值）**，关系表达式的值是0或者1，也可以认为是True或者False。

#### 2）逻辑运算符和逻辑表达式
用**逻辑运算符** 将 关系表达式 连接起来的 就是逻辑表达式。

**双目运算符：**要求有两个运算量，分别位于符号两侧。

比如`(a > b) && (c > d);`  `(a > b) || (c > d);`

`!非` 是一个**单目运算符**。比如：`! (a > 3);`

`a && b`: 若a和b都为真，则输出为True(1);
`a || b`: 若a和b有一个为真，则输出为真；

##### 计算机在进行逻辑判断时，不等于0的值全部认为True

**总结来说：**由系统给出的逻辑运算结果不是0就是1，不可能是其他数值🙅‍♂️，而在逻辑表达式中作为参加逻辑运算的运算对象，是0就表示假，非0就表示真。

```
if(4 == true)	//假;因为计算机默认true为1
if(4 && 5)		//真，式中4和5都属于逻辑表达式中的运算对象且都不等于0。
```

**逻辑运算符求值问题：**在逻辑表达式求解中，不是所有逻辑运算符都会被执行，只有在必须执行下一个逻辑运算符才能求出表达式的结果时，才执行该运算符。

```
a && b && c	//只有a为真（非0）才需要判断b，只有a，b都为真才判断c。
a || b || c	//只要a为真就不需要判断b和c，只有a，b都不为真才会判断c。
```

### 2、if语句详解
#### 1）if常用的三种结构
**if语句（选择结构的代表性语句）：**用来判断给定的条件是否满足，根据判断的结果（真，假）决定执行给出的两种操作之一。

**if 的三种格式：**

- `if (表达式)  语句`   如果表达式中的条件满足则执行该语句。
⚠️千万不要在if (条件)后加冒号或分号（和PYTHON有差别），加上后会破坏掉选择关系。

- `if (表达式)  语句1  else	语句2`	如果表达式中的条件满足，则执行语句1；否则执行语句2。

```
if (表达式1) 语句1		//	如果表达式1成立执行语句1...只能执行一个语句！
else if (表达式2) 语句2
else if (表达式3) 语句3
...
else (表达式n) 语句n
```

#### 2）if语句的嵌套
```
if ()
	if() 语句1
	else 语句2
else                           
	if() 语句3
	else 语句4
```
### 3、条件运算符和switch语句

#### 1）条件运算符	`?	:`

```
if (a>b)
	max = a;								
else						=>	max = (a>b)?a:b							 //如果a>b为真则取a作为整个值	
	max = b;
```

**条件运算符**是一个**三目运算符**是唯一一个三目运算符，结合顺序是从右到左的。
**格式：**`表达式1	？	表达式2	：表达式3;`
**执行过程：**如果表达式1输出为真 则值为运行表达式2的值，否则取表达式3的值。

#### 2）switch语句

**格式：**

```
switch(表达式)	//这个位置不能加分号或者冒号
{
case 常量表达式1:
	{
		1行或者多行语句						
	}
	break;

case 常量表达式2:
	{
		1行或者多行语句
	}
	break;
...
default:
	1行或者多行语句
	break;
}		//switch 后面的表达式的值若满足任何某个case后面的常量表达式的值，则执行该case后面的一行或者多行语句，直到遇到break跳出整个switch语句；如果所有case都不满足，则执行default中的语句。
```
**说明⚠️：**
1. switch后面的表达式一般都是整形变量或者表达式，其他类型也允许，但是很罕见；
2. 每个case后面的常量表达式必须互不相同；
3. break不能丢掉；如果忘记break，会导致执行完一个case中包含的语句后，流程继续会执行下一个case条件中包含的语句（不管该case中条件是否满足）；
4. case后可以有多行语句不用加{}；
5. default可以没有；
6. 多个case可以共用一组执行语句；


## 四 循环控制

### 1、概述，goto，while，do while语句精解
> 循环控制语句概述

**循环结构♻️：**`goto`，`while`，`do while`，`for`
#### 1）goto语句
**goto语句：** *无条件转向语句，用来跳转到某个程序位置进行执行。*
**一般形式：**`goto 语句标号；`	其中语句标号是一个标志符（只能由数字，字母，下划线三种字符组成，且第一个字符必须是字母或者下划线，且不能是保留字。

**goto语句主要用途：**
1. 与if语句一起构成循环结构；
2. 从循环体内跳转到循环体外。//不推荐，破坏了结构化程序设计原则，除非万不得已。

```
//1到100的加法运算
loop:
	if(i<=100)
		{
		sum = sum + i;
		i++;
		goto loop;
		}
printf(“%d\n”,sum);
```
*目前goto语句应用场合比较少；goto语句不能跨函数。*

#### 2）while语句，当型循环结构
**格式：**`while (表达式) 要执行的语句`
**特点：**先判断表达式的值，如果表达式的值为真，就执行语句；如果为假，则循环体内的语句一次也不执行。

##### ⚠️在循环体内需要有使循环趋向于结束的语句；

#### 3）do while语句，直到型循环结构
**一般形式：**`do 要执行的语句	while（表达式）`

### 2、for语句精解	*和python中的有差别*
#### 1）for语句的一般形式
`for(表达式1; 表达式2; 表达式3) 内嵌的语句`
**执行过程：**

- 先求解表达式1的值；
- 再求解表达式2的值；
	- 若表达式2值为真（非0），则执行for语句中指定的内嵌语句，再求解表达式3的值，反复循环步骤2，一直到表达式2的值为假；
	- 若表达式2的值为假（0），则整个for循环结束，程序流程跳转到for语句后面的语句去执行。

##### ⚠️表达式1的值只会被执行一次
###### for语句最常用也是最简单的引用形式：
`for(循环变量赋初值; 循环变量结束条件; 循环变量增加值) 内嵌的语句`

```
int i, sum=0;
for(i=0; i<=100; i++)	//称i为循环变量
{
	sum = sum + i;
}       //先执行i=0；当i<=100为真时执行sum = sum+ i 和 i++；
```
⚠️

- 表达式1可以省略，但 `; `不能省略，当表达式1省略时，应该在for之前就给循环变量赋于初值；
- 表达式2可以省略，但 `;` 不能省略，也就是不判断循环条件，就必须用break语句终止循环；

```
for(i=1;  ; i++)
{
	sum = sum + i;
	if (i >= 100)
		break;
}
```
- 表达式3也可以省略，把表达式3也写入循环体内；
- 表达式1和表达式3可以是一般表达式或者逗号表达式；
- 表达式2可以式关系表达式或者逻辑表达式；如：`i<=100;` `i>100 && i <=500; `...

如果表达式全省略，则默认为真 => 一直执行内嵌语句。

### 3、循环的嵌套，比较，break语句，continue语句

#### 1）循环的嵌套		while，for，do while
> 一个循环体内又包含另外一个循环；for套for最常用

#### 2）几种循环语句的比较
- 多数情况下，这些循环之间可以相互替代，但是不提倡使用goto循环，因为goto循环破坏了结构化程序设计。
- while循环和for循环，是先判断表达式的值，后执行语句；而do while循环先执行语句，后判断表达式的值。
- 对while，do while，for这三种语句可以用break语句跳出循环，用continue结束本次循环。

#### 3）break和continue语句
`break`：跳出整个循环；
`continue`：跳出本次循环；继续进行下次循环；
##### ⚠️break语句不能在switch和循环语句之外使用；在switch语句中使用break只能跳出switch不能跳出switch之外的循环；break只能跳出语句所在的这层循环；

**continue的作用：**结束本次循环，跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判断。
 

## 五 数组
### 1、一维数组
**构造类型：**把基本的数据类型（int，float，char，double）进行一些变换得到的数据类型。
**数组**就是**构造类型**。

**一维数组的定义方式：**
`类型说明 数组名字 [常量表达式];`
*like*	`int a[10];	//定义了一个一维数组，名字a，这个数组有10个元素；`
1. 数组名后边的必须是方括号扩起来；一般常量表达式都是数字，**不能是变量，c语言不允许对数组大小做动态定义，也就是说数组大小不能依赖于程序运行；**
2. 所谓一维数组，就是带一组[ ]，二维数组是[ ] [ ]；
3. 十个元素是a[0], a[1], a[2], ... , a[9]；
###### 可以给a[10]赋值，语法上没错，但这个赋值就会产生极大的程序隐患，因为a[10]的内存并不属于你能控制的内存，但是，却在这个内存地址写入了数据，结果很有可能把程序中其他某个用到的这个内存地址的变量的值给覆盖掉。 

**一维数组的引用：**
C语言规定，*只能引用数组中的元素，而不能引用整个数组；*
**表现形式：**	`数组名 [下标]`

**一维数组的初始化：**

`int a[10] = {...};
//正好10个数字，用大括号括起来，每个数字之间用 “,” 分开。`

*可以给部分元素赋值；未赋值元素默认为0；*

###### 如果对全部数组元素赋初值，可以不指定数组长度。
`int a[] = {1,2,3,4,5};	`

### 2、二维数组
**二维数组的一般形式：**
###### 类型说明符 数组名[常量表达式][常量表达式]

```
float a[3][4];	//理解成一个3行4列的数组;
				//第二种理解方式：理解为a是一个一维数组有三个元素，每个元素都是一个包含四个元素的一维数组
```
###### 在内存中多维数组排列顺序：第一维下标变化最慢，越靠后的维度下标变化快。
**二维数组的引用：**
###### 数组名[下标][下标]
> 每个元素都可以当作一个单独**变量**来看，使用*算数运算符*。

**二维数组的初始化：**

- 分行给二维数组赋初值

```
int a[2][2] = {{1,2},{3,4}};
```
***快捷键***

**结束调试：**`shift+fn+F5`
**快速监视：**`shift+fn+F9`

- 将所有数据放在一个大括号里

```
int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
```

- 给部分元素赋初值

###### 未给初值默认为0

### 3、字符数组*
> 用来存放字符数据的数组，一个元素存放一个字符。

```
char c[10];
c[0] = 'I';
c[1] = 'a';
//...
//字符数据的初始化
char c[10] = {'I',' ','a','m',' ','h','a','p','p','y'};
//如果提供的初值个数和预定的数组长度相同，定义时可以省略数组长度，系统会自动根据初值个数确定数组长度

char c[12] = {'I',' ','a','m',' ','h','a','p','p','y'};
//初值个数 < 数组长度，则只将这些字符赋值给数组中前面的元素，其余的元素值可能给\0，也可能无法确定。

char d[] = {"I am happy"};	//常用，同样可以用index取到数组中的元素
char d[] = "I am happy";
//用字符串的方式给字符数组赋初值，得到的结果最后一位会多一位 \0 是字符串的结束标记🔚
printf("%s",d)	//printf输出string，到第一个\0结束

//0 == '\0' 字符串结束标记
```

从键盘输入一个字符串，用`scanf`完成

```
char str[100];
scanf("%s", str);	//并没有使用&str的原因是str本身就代表该数组的起始地址
printf("%s\n", str);	//输入一个字符串的时候不能加入空格，否侧空格后的内容会被丢弃
printf("%d\n", &str);	//可以以十进制数打印出数组的起始地址(实际上是0x开头的十六进制数)
```

#### 字符串的处理函数
引入`string.h`

```
#include <string.h>
```

1. `puts(字符串数组)`:将一个字符串输出到屏幕🖥，会自动换行；
2. `gets(字符数组名)`:从键盘⌨️输入一个字符串到字符数组中；
3. `strcat(字符数组1, 字符数组2)`:把2连接到1的后面保存到str1；
4. `strcpy(字符数组, 字符串)`:用于**字符数组赋值**。使用字符串覆盖掉左边字符数组的值(字符串也可以是一个字符数组，右边数组大小最好小于左边)；
5. `strcmp(字符串1，字符串2)`:比较两个字符串的内容：
	1. 如果字符串1 = 字符串2，返回0；
	2. 如果字符串1 > 字符串2，返回正整数1；
	3. 如果字符串1 < 字符串2，返回负整数-1。(比较规则：从左到右逐个字符比较(按ascii码值大小比较)，一般只用来比较=和≠。)
6. `strlen(字符串)`:测试字符串长度，不包含`\0`，返回值是字节数(`sizeof`操作符与内容无关，例如: sizeof(int)=4)


## 六 函数
### 1、函数的基本概念和定义
调用一个函数前需要先声明(定义)
主函数**main**前加的**int**是函数返回值类型，就像**void**无返回类型(**无返回类型**`void`，函数没有返回值)一样，在vscode编译环境下如果不加int，默认的是系统自动假设整型的返回值类型。但是建议使用`int main():`函数末尾使用`return 0`。

1. 一个项目由一个或多个源程序文件组成。函数可以分别放在这些源程序文件里并被所有的源程序文件公用；
2. 函数不能嵌套，但是可以互相调用；

~~**嵌套**~~的意思是：

```
void function1():
{
	void function2():
		{
		}
}
```
**调用**的意思是：

```
void function1():
{
	function2();
}
```

**函数的分类：**
1. 库函数，比如`printf`，`strcpy`，`strcat`，`strcmp`。可以直接调用，不需要自己定义，需要用`#include <>`引入头文件；
2. 自定义函数，用于解决特殊需求。
**函数参数：**调用函数时，希望把一些数据传递给参数，该函数需要一些变量来接收这些数据，这些接受数据的变量，就叫做函数参数。
**函数定义的一般形式**：

```
返回类型 函数名(形式参数列表)	//函数中的参数叫形参，调用时输入的参数叫实际参数，实参
{
	语句;
	return 返回值;
}
```

**快捷键**
**debug时查看函数调用步骤**(进入调用堆栈) `fn+F11`
(如果使用`fn+F10`会跳过实际在函数中运行的步骤直接跳到结果)
**使用键盘向左向右自由选择**`shift+/`

1. **函数定义**的第一行没有分号，有分号的话叫**函数声明**；
2. 形式参数在函数**调用之前并不分配内存**，**调用的时候分配内存**；**调用结束后**，**内存被释放**。在函数外，不可以使用形参。也就是函数调用时的压栈和出栈；
3. 实际参数可以是常量、变量、表达式，实参的值自动赋给形参。如果实参为数组名(数组名代表的是数组首地址)，则传递进去的不是变量而是**数组首地址**；
4. 形参数量和类型必须和实参数量和类型**保持一致**；
5. 实参变量对形参变量的数据传递是“值传递”，是单向传递。

### 2、函数调用方式及嵌套调用
**函数调用的一般形式：**

```
函数名(实参列表);
//若调用的是没有形参的函数
函数名();
//若实参列表包含多个参数
函数名(?,?,...);
```
**函数调用的方式：**

```
int whichmax(int a, int b)
{
	if (a > b)
		return a;
	return b;
}
```
- 把函数作为一个语句；
`whichmax(12, 60);`
- 函数出现在表达式中，这种表达式叫做函数表达式，要求函数带回一个确定的值以参加表达式运算；
`result = whichmax(12, 60) * 100;`
- 函数调用可以作为一个函数的实参；
`whichmax(8, whichmax(12,60));`

#### 函数声明
> 函数声明需要放在源代码具体的函数之前(源代码的开头)，才能保证这些具体的函数在被调用时是声明过的函数。

**函数声明的一般形式：**

```
类型标志符 函数名(形参列表);
```

和**函数定义**的区别在*大括号及内的语句&分号*。
#### 函数的嵌套调用
> C语言中不允许函数的嵌套定义，但允许函数的嵌套调用

### 3、函数递归调用精彩演绎
> **调用栈**，把形式参数、函数调用关系、局部变量*(在函数内部定义的变量，当函数整个执行完后，局部变量所占用的内存会被系统回收，回收后该变量将不再可用)*。

因为递归调用产生的死循环问题，递归操作必须要有一个出口，也叫做递归终止条件。

```
int dg_jiecheng(int n);

int main()
{
	int end = dg_jiecheng(5);
	printf("阶乘结果是%d", end);
	return 0;
}
int dg_jiecheng(int n)
{
	if (n == 1)
	{
		return 1;
	}
	else
	{
		dg_jiecheng = dg_jiecheng(n-1) * n;
	}
	return dg_jiecheng;
}
```
递归调用像掰白菜🥬一样，从第一次调用开始 -> ... -> 第n次调用开始 -> 第n次调用结束 -> ... -> 第一次调用结束，返回值。
### 4、数组作为函数参数
1. 数组元素可以当成变量使用，来作为函数调用的实参
2. **数组名**作为函数实参

数组名代表的是**数组首地址**，此时，函数中形参也应该用数组名(也可以是数组指针)。在调试时，使用`fn+shift+F9`可以打开**快速监视**窗口，使用`&X(查看的变量)`查找该变量的内存地址。

***强调***
数组名作为函数参数时，**不**是“值传递(形参是分配内存的)”的概念了，不是单向传递，而把实参数组的开始地址传递给了形参数组(不再额外分配地址)。这样**两个数组就会共同占有一段内存**，这叫做**地址传递**。也就是说，形参数组中各个元素发生变化会导致实参数组元素的值也发生改变。
> 形参数组的大小可以不指定或与实参数组大小不一致，C编译器不对形参数组大小不做检查，只是将首地址传递给形参，形参中能够使用的内存地址就是实参中定义的变量地址

### 5、局部变量和全局变量
- **局部变量：**
	- **在一个函数内部定义的变量叫局部变量**，只在本函数范围内有效(包括main函数)
	- 不同函数可以使用相同的变量名，互不干扰
	- 虽然地址传递公用一个内存地址，但是仍不可以跨函数使用变量
	- 形式参数也是个局部变量

**一种特殊写法**

```
int main()
{
int a, b;
//用大括号写一段代码段，大括号括起来的叫复合语句，在该复合语句中定义变量，这些变量只在本复合语句中有效，这种复合语句也叫程序块
{
int c;	//有效范围只在复合语句内，一旦离开复合语句变量c的内存就被释放
 c = a + b;
}
}
```
- **全局变量：**
	- **在函数外定义的变量叫全局变量(外部变量)**，可以为本文件中所有函数共用
	- **优点：**增加了函数与函数之间的数据联系渠道
	- **缺点：**
		- 只有在必要时才使用全局变量，全局变量在程序运行整个周期都占用内存
		- 降低了函数的通用性
		- 降低程序清晰性和可读性

> 如果某个函数想引用在它后面定义的全局变量，则可以用一个关键字`extern`做一个“**外部变量说明**”，表示该变量在函数的外部定义

```
extern int x1, x2;	//外部变量说明(不分配内存)
void func1()
{
	...;	
}
//or
void func1()	//在函数内声明，只能在函数内部使用该全局变量
{
	extern int x1, x2;
	...;
}
``` 
> 在同一个源文件中，如果全局变量和局部变量重名，则在局部变量作用范围内，全局变量不起作用

### 6、变量的存储和引用，内部和外部函数
#### 变量的存储类别：
> 从变量存在的时间(生存期)角度来划分，变量可以划分为：**静态存储变量**和**动态存储变量**。

**静态存储变量：**程序运行期间分配固定存储空间的变量。
*这种存储变量的方式叫静态存储方式。*

**动态存储变量：**程序运行期间根据需要进行动态分配存储空间的变量。
*这种存储变量的方式叫动态存储方式。*

全局变量(在函数外部定义的)放在静态存储区中，程序开始执行时给全局变量分配存储区，程序执行完毕后释放这些存储区。在程序执行过程中它们占据固定的存储单元，而不是动态的分配和释放。

函数形参、局部变量、函数调用时的数据和返回地址都存储在动态存储区中，这些数据在函数开始调用时分配存储空间，函数调用完毕，空间释放。如果两次调用同一个函数，分配给此函数局部变量等的存储空间地址可能是不同的。
#### 局部变量的存储方式：
- **传统情形：**
	- 函数的局部变量：函数被调用时分配存储空间，执行完成后自动释放其所占有的存储空间
- **特殊情形：**
	- ***局部静态变量***：用`static`加以说明；能够保留原值，占用的内存单元不释放。下一次调用该函数时，不再重新赋值，该变量的值是上次调用结束时的值
		- 局部静态变量在静态存储区内分配存储单元，在编译时赋初值
		- 如果不赋初值的话，系统默认静态局部变量的初值为0
		- 虽然局部静态变量在函数调用结束后仍然存在，但其他函数时不能引用

**全局变量跨文件引用：**使用`extern`在文件头做外部变量说明。
在定义全局变量时前面加上`static`，则该全局变量只能在本文件中使用。
#### 函数的跨文件引用
根据函数能否被其他文件调用，将函数分为：

1. **内部函数**(静态函数)：在函数定义最前面加上`static`，使函数只局限于所在文件
2. **外部函数**：跨文件调用时，需要在文件头加函数声明`函数返回类型 函数名(形参表);`

## 七 编译预处理
### 1、宏定义
###### 一个项目可以通过编译、链接最终形成一个可执行文件；每个源文件(.cpp)都会单独编译，编译成一个目标文件(.o，也可能是.obj，扩展名与操作系统相关)；然后系统将这些.o文件进行链接，形成一个可执行文件。

**编译过程：**
> 1)预处理；
> 2)编译(->汇编语言)：词法、语法分析，目标代码生成、优化，产生一些临时文件
> 3)汇编(->机器语言)：产生.o(.obj)目标文件

**C语言一般提供三种预处理功能：**
> 都以`#`开头

1. ***宏定义***
2. 文件包含
3. 条件编译

#### 不带参数的宏定义
> 用一个指定的标识符(宏名)来代表一个字符串

**一般形式：**`#define 标识符/宏名 字符串`

```
//用PI代替"3.1415926"这个字符串
#define PI 3.1415926
```
